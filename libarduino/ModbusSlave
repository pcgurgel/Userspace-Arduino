#ifndef MODBUS_SLAVE_H
#define MODBUS_SLAVE_H
/****************************************************************************
 * 
 * ModbusSlave library implementing a Modbus RTU Slave for Arduino
 * Modified by S.Marco. mailto:sammarcoarmengol@gmail.com
 * Based on the work published by jpmzometa at 
 * http://sites.google.com/site/jpmzometa/arduino-mbrt
 * 
 * Based also on http://pcscada.com.au by P.Costigan email: phil@pcscada.com.au
 * 
 * These library of functions are designed to enable a program send and
 * receive data from a device that communicates using the Modbus protocol.
 * 
 * Copyright (C) 2000 Philip Costigan  P.C. SCADA LINK PTY. LTD.
 * 
 * This file is part of ModbusSlave.
 * 
 * ModbusSlave is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 * 
 * 
 * The functions included here have been derived from the 
 * Modbus Specifications and Implementation Guides
 * 
 * http://www.modbus.org/docs/Modbus_over_serial_line_V1_02.pdf
 * http://www.modbus.org/docs/Modbus_Application_Protocol_V1_1b.pdf
 * http://www.modbus.org/docs/PI_MBUS_300.pdf
 * 
 ****************************************************************************/

/****************************************************************************
 * BEGIN MODBUS RTU SLAVE FUNCTIONS
 ****************************************************************************/
#if defined(ARDUINO) && ARDUINO >= 100
#include "Arduino.h"
#else
#include "WProgram.h"
#endif

class ModbusSlave {
private:
  unsigned char slave;
  char txenpin;
  int *regs;
  unsigned int regs_size;
  int *inputregs;
  unsigned int inputregs_size;
  bool *coils;
  unsigned int coils_size;
  bool *inputs;
  unsigned int inputs_size;


  unsigned int crc(unsigned char *buf, unsigned char start, unsigned char cnt);
  void build_read_packet(unsigned char function, unsigned char bytes, unsigned char *packet);
  void build_write_packet(unsigned char function, unsigned int start_addr, unsigned char count, unsigned char *packet);
  void build_write_single_packet(unsigned char function, unsigned int write_addr, unsigned int reg_val, unsigned char* packet);
  void build_error_packet(unsigned char function,unsigned char exception, unsigned char *packet);
  void modbus_reply(unsigned char *packet, unsigned char string_length);
  int send_reply(unsigned char *query, unsigned char string_length);
  int receive_request(unsigned char *received_string);
  int modbus_request(unsigned char *data);
  int validate_request(unsigned char *data, unsigned char length);
  int write_regs(unsigned int start_addr, unsigned char *query, int *regs);
  int preset_multiple_registers(unsigned int start_addr,unsigned char count,unsigned char *query,int *regs);
  int read_registers(unsigned int start_addr, unsigned char reg_count, int *regs, unsigned char function);  //for holding and inputs  (int values)
  int write_single_register(unsigned int write_addr, unsigned char *query, int *regs);  
  void configure(long baud, char parity, char txenpin);
  int write_single_coil(unsigned int write_addr, unsigned char *query, bool *coils);
  int read_booleans(unsigned int write_addr, unsigned char count, bool *vector, unsigned char function);   //for coils and input status (boolean values)

public:
/* 
 * configure(slave, baud, parity, txenpin)
 *
 * sets the communication parameters for of the serial line.
 *
 * slave: identification number of the slave in the Modbus network (1 to 127)
 * baud: baudrate in bps (typical values 9600, 19200... 115200)
 * parity: a single character sets the parity mode (character frame format): 
 *         'n' no parity (8N1); 'e' even parity (8E1), 'o' for odd parity (8O1).
 * txenpin: arduino pin number that controls transmision/reception
 *        of an external half-duplex device (e.g. a RS485 interface chip).
 *        0 or 1 disables this function (for a two-device network)
 *        >2 for point-to-multipoint topology (e.g. several arduinos)
 */
  void configure(unsigned char slave, long baud, char parity, char txenpin);

  /* 
 * setup_regs(vector, size)
 *
 * Setup Holding registers. For 2 bytes int values (read/write). Ex.: A value of a timer.
 * 
 * vector: an array with the holding registers. They start at address 1 (master point of view)
 * size: total number of holding registers.
 */
 void setup_regs(int* vector, unsigned int size);	     

 /* 
 * setup_inputregs(vector, size)
 *
 * Setup Input registers. For 2 bytes int values (read only). Ex.: A temperature sensor.
 * 
 * vector: an array with the input registers. They start at address 1 (master point of view)
 * size: total number of input registers.
 */
 void setup_inputregs(int* vector, unsigned int size);	

 /* 
 * setup_coils(vector, size)
 *
 * Setup Coils. For on/off (boolean) values (read/write). Ex.: A relay controlling a lamp.
 * 
 * vector: an array with the coils. They start at address 0 (master point of view)
 * size: total number of coils.
 */
 void setup_coils(bool* vector, unsigned int size);	

/* 
 * setup_inputs(vector, size)
 *
 * Setup Inputs. For binary (on/off) (read only). Ex.: A door sensor (reed-switch)
 * 
 * vector: an array with the inputs. They start at address 0 (master point of view)
 * size: total number of inputs.
 */
 void setup_inputs(bool* vector, unsigned int size);	


/*
 * update()
 * 
 * checks if there is any valid request from the modbus master. If there is,
 * performs the requested action
 * 
 * returns: 0 if no request from master,
 * 	NO_REPLY (-1) if no reply is sent to the master
 * 	an exception code (1 to 4) in case of a modbus exceptions
 * 	the number of bytes sent as reply ( > 4) if OK.
 */
  int update(); 

  ModbusSlave()
  {
	regs_size = 0;
	inputregs_size = 0;
	coils_size = 0;
	inputs_size = 0;
  }

};

#endif
